package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.39

import (
	"context"
	"time"

	"github.com/amir/graphql-c1/graph/model"
	model2 "github.com/amir/graphql-c1/internal/model"
)

// CreateGist is the resolver for the createGist field.
func (r *mutationResolver) CreateGist(ctx context.Context, input model.GistInput) (*model.Gist, error) {
	files := make([]*model2.CreateFile, 0, len(input.Files))

	for _, file := range input.Files {
		files = append(files, &model2.CreateFile{
			FileName: file.FileName,
			Content:  file.Content,
		})
	}

	gist, err := r.svc.GistCreate(ctx, model2.CreateGistRequest{
		Description: input.Description,
		Public:      input.Public,
		Files:       files,
	})
	if err != nil {
		return nil, err
	}

	return gistToGraph(gist), nil
}

// UpdateGist is the resolver for the updateGist field.
func (r *mutationResolver) UpdateGist(ctx context.Context, gistID string, input model.GistInput) (*model.Gist, error) {
	files := make([]*model2.CreateFile, 0, len(input.Files))

	for _, file := range input.Files {
		files = append(files, &model2.CreateFile{
			FileName: file.FileName,
			Content:  file.Content,
		})
	}

	gist, err := r.svc.GistUpdate(ctx, gistID, model2.CreateGistRequest{
		Description: input.Description,
		Public:      input.Public,
		Files:       files,
	})
	if err != nil {
		return nil, err
	}

	return gistToGraph(gist), nil
}

const (
	timeFormat = "2006-01-02T15:04:05.000"
)

// PublicGists is the resolver for the publicGists field.
func (r *queryResolver) PublicGists(ctx context.Context, since string, perPage *int, page *int) ([]*model.Gist, error) {
	parsedTime, err := time.Parse(timeFormat, since)
	if err != nil {
		return nil, err
	}

	perPageInt := defaultPerPage
	if perPage != nil && *perPage != 0 {
		perPageInt = *perPage
	}

	pageInt := 0
	if page != nil {
		pageInt = *page
	}

	gists, err := r.svc.PublicGists(ctx, parsedTime, pageInt, perPageInt)
	if err != nil {
		return nil, err
	}

	return gistsToGraph(gists), nil
}

// GistByID is the resolver for the gistByID field.
func (r *queryResolver) GistByID(ctx context.Context, id string) (*model.Gist, error) {
	gist, err := r.svc.GistByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return gistToGraph(gist), nil
}

// GistComments is the resolver for the gistComments field.
func (r *queryResolver) GistComments(ctx context.Context, gistID string, perPage *int, page *int) ([]*model.GistComment, error) {
	perPageInt := defaultPerPage
	if perPage != nil && *perPage != 0 {
		perPageInt = *perPage
	}

	pageInt := 0
	if page != nil {
		pageInt = *page
	}

	comments, err := r.svc.GistComments(ctx, gistID, pageInt, perPageInt)
	if err != nil {
		return nil, err
	}

	return commentsToGraph(comments), nil
}

// GistCommits is the resolver for the gistCommits field.
func (r *queryResolver) GistCommits(ctx context.Context, gistID string, perPage *int, page *int) ([]*model.GistCommit, error) {
	perPageInt := defaultPerPage
	if perPage != nil && *perPage != 0 {
		perPageInt = *perPage
	}

	pageInt := 0
	if page != nil {
		pageInt = *page
	}

	commits, err := r.svc.GistCommits(ctx, gistID, pageInt, perPageInt)
	if err != nil {
		return nil, err
	}

	return commitsToGraph(commits), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
